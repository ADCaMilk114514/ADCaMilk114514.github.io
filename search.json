[{"title":"测试","url":"/2025/09/02/%E6%B5%8B%E8%AF%95/","content":"\n\n\n\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main() {    int a,b;    cin&gt;&gt;a&gt;&gt;b;    cout&lt;&lt;a+b&lt;&lt;endl;    return 0;}\n\nios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\n你好。\n\n首页 - 洛谷 | 计算机科学教育新生态\n123456\n\n\n1\n1\n1\n\n\n\n2\n2\n2\n\n\n3\n3\n3\n\n\n4\n4\n4\n\n\n\n1\n2\n3\n4\n\naaa\naaa\n11111\n\nawa\nqwq\npwp\nqaq\n\n","categories":["2025"],"tags":["科技·工程"]},{"title":"浅谈重链剖分","url":"/2025/09/29/%E6%B5%85%E8%B0%88%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86/","content":"浅谈重链剖分\n\n介绍重链剖分就是一些善（du）良（liu）出题人为了恶心我们加强难度，把序列上的问题转到树上的解决方案。具体方法就是把树分成一个个链，通过进行对链的修改实现对整棵树的修改。\n步骤DFS1第一次深度优先搜索维护出每个节点的深度父亲，子树大小，还有你的重链要往哪一个儿子走（简称重儿子）。  \n因为我们要让划分出的重链数量尽可能的少，所以说我们要挑子树最大的那个儿子作为重儿子。\n这样的话树上的每一条路径都能拆成不超过  条重链。\n因为如果向下经过轻边的话，所在子树大小至少会除以二。\nDFS2要想在把树划分成重链，显然不止这些。\n因为要对重链进行修改，所以说一条重链的节点编号必须是连续的。所以说要维护每个节点所在重链的顶端是谁（或者说是它属于哪一条重链），以及这个节点的新编号。\n最后根据编号将它维护到树形数据结构上。\n子树修改/查询最简单的一集。\n注意到子树内的编号都是连续的，所以直接对  进行操作。\n做完了。\n链上修改/查询类似一个求 LCA 的过程。\n当两个点不在同一条重链上的时候，就跳那个重链顶端深度更小的结点，对所在的重链进行修改。\n跳到同一条重链直接做就行了。\n时间复杂度显然是  的。\n例题P3384P3384 【模板】重链剖分/树链剖分 - 洛谷\n模板题，没啥好说的，按照上面的直接做就行了。\n#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define lowbit(x) (x&amp;-x)const int N = 1e5 + 10;int n, T, r, P, cnt, son[N], depth[N], fa[N], sz[N], id[N], top[N], w[N], c1[N], c2[N];vector&lt;int&gt; g[N];//---------这里是数据结构部分-------------inline void add(int l, int r, int x) {\tint ad1 = (l - 1) * x % P, ad2 = r *x % P;\tfor (int i = l; i &lt;= n; i += lowbit(i)) c1[i] = (c1[i] + x) % P, c2[i] = (c2[i] + ad1) % P;\tfor (int i = r + 1; i &lt;= n; i += lowbit(i)) c1[i] = (c1[i] - x + P) % P, c2[i] = (c2[i] - ad2 + P) % P;}inline int query(int x) {\tint ret = 0;\tfor (int i = x; i; i -= lowbit(i)) ret = (ret + c1[i] * x % P) % P, ret = (ret - c2[i] + P) % P;\treturn ret;}inline int ask(int l, int r) {\treturn (query(r) - query(l - 1) + P) % P;}//---------这里是树剖部分----------//dfs基本上都是千篇一律，直接背就行inline void dfs1(int f, int u) {\tfa[u] = f, sz[u] = 1, depth[u] = depth[f] + 1;\tint tmp = -1;\tfor (int v : g[u]) {\t\tif (v == f) continue;\t\tdfs1(u, v);\t\tsz[u] += sz[v];\t\tif (sz[v] &gt; tmp) tmp = sz[v], son[u] = v;\t}}inline void dfs2(int f, int u) {\ttop[u] = f, id[u] = ++cnt;\tadd(id[u], id[u], w[u]);\tif (son[u] == 0) return;\tdfs2(f, son[u]);\tfor (int v : g[u]) {\t\tif (v == fa[u] || v == son[u]) continue;\t\tdfs2(v, v);\t}}//这里是路径，不同的题可能略有修改inline void addPath(int u, int v, int k) {\tk %= P;\twhile (top[u] != top[v]) {\t\tif (depth[top[u]] &lt; depth[top[v]]) swap(u, v); //LCA 显然是优先跳小的\t\tadd(id[top[u]], id[u], k);\t\tu = fa[top[u]];\t}\tif (depth[u] &gt; depth[v]) swap(u, v); //深度大的在后\tadd(id[u], id[v], k);}//和addPath一样就不讲了inline int askPath(int u, int v) {\tint res = 0;\twhile (top[u] != top[v]) {\t\tif (depth[top[u]] &lt; depth[top[v]]) swap(u, v);\t\tres = (res + ask(id[top[u]], id[u])) % P, u = fa[top[u]];\t}\tif (depth[u] &gt; depth[v]) swap(u, v);\tres = (res + ask(id[u], id[v])) % P;\treturn res;}//子树没啥好讲的inline int askSon(int u) {\treturn ask(id[u], id[u] + sz[u] - 1);}inline void addSon(int u, int k) {\tk %= P;\tadd(id[u], id[u] + sz[u] - 1, k);}//---------这里是主函数部分----------signed main() {\tcin &gt;&gt; n &gt;&gt; T &gt;&gt; r &gt;&gt; P;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\tfor (int i = 1; i &lt; n; i++) {\t\tint u, v;\t\tcin &gt;&gt; u &gt;&gt; v;\t\tg[u].push_back(v);\t\tg[v].push_back(u);\t}\tdfs1(0, r), dfs2(r, r);\tint op, u, v, k;\twhile (T--) {\t\tcin &gt;&gt; op &gt;&gt; u;\t\tif (op == 1) {\t\t\tcin &gt;&gt; v &gt;&gt; k;\t\t\taddPath(u, v, k);\t\t} else if (op == 2) {\t\t\tcin &gt;&gt; v;\t\t\tcout &lt;&lt; askPath(u, v) &lt;&lt; endl;\t\t} else if (op == 3) {\t\t\tcin &gt;&gt; k;\t\t\taddSon(u, k);\t\t} else {\t\t\tcout &lt;&lt; askSon(u) &lt;&lt; endl;\t\t}\t}\treturn 0;}\n\nP1505P1505 [国家集训队] 旅游 - 洛谷\n也是几乎板子，线段树稍微改一改。\n但是这里有一个 trick 就是边权转点权。\n对于每一条边，把它的边权转移到通向的深度更大的点。\n这里有一个细节，进行链上修改的时候，跳到了同一条重链，这个时候深度更小的点的点权是不会进行修改的，然后就可以直接做了。\n毒瘤题目的下标是从零开始的。\n#include &lt;bits/stdc++.h&gt;using namespace std;#define debug cerr&lt;&lt;\"The code runs successfully.\\n\";#define endl '\\n'#define TRACE 1#define tcout TRACE &amp;&amp; cout#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);#define int long long#define lson(x) (x&lt;&lt;1)#define rson(x) (x&lt;&lt;1|1)const int P = 998244353;const int Base = 33331;const int INF = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10, M = 2e6 + 10;struct segtree {\tint l, r, sum, max, min, lazy;} s[N &lt;&lt; 2];pair&lt;int, int&gt; edge[N];vector&lt;pair&lt;int, int&gt;&gt; g[N];int n, q, id[N], cnt, son[N], siz[N], fa[N], w[N], top[N], dep[N], wssb[N];inline void calc(int p) {\ts[p].lazy ^= 1;\ts[p].sum = -s[p].sum;\ts[p].max = -s[p].max;\ts[p].min = -s[p].min;\tswap(s[p].max, s[p].min);}inline void pushup(int p) {\ts[p].sum = s[lson(p)].sum + s[rson(p)].sum;\ts[p].min = min(s[lson(p)].min, s[rson(p)].min);\ts[p].max = max(s[lson(p)].max, s[rson(p)].max);}inline void pushdown(int p) {\tif (!s[p].lazy) return;\tcalc(lson(p)), calc(rson(p));\ts[p].lazy ^= 1;}inline void build(int p, int l, int r) {\ts[p].l = l, s[p].r = r;\tif (l == r) {\t\ts[p].sum = s[p].min = s[p].max = w[l];\t\treturn;\t}\tint mid = l + r &gt;&gt; 1;\tbuild(lson(p), l, mid);\tbuild(rson(p), mid + 1, r);\tpushup(p);}inline void change1(int p, int x, int k) {\tif (s[p].l == s[p].r) {\t\ts[p].sum = s[p].max = s[p].min = k;\t\treturn;\t}\tpushdown(p);\tint mid = s[p].l + s[p].r &gt;&gt; 1;\tif (mid &gt;= x) change1(lson(p), x, k);\telse change1(rson(p), x, k);\tpushup(p);}inline void change2(int p, int l, int r) {\tif (s[p].r &lt; l || r &lt; s[p].l) return;\tif (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) {\t\tcalc(p);\t\treturn;\t}\tpushdown(p);\tint mid = s[p].l + s[p].r &gt;&gt; 1;\tchange2(lson(p), l, r), change2(rson(p), l, r);\tpushup(p);}inline int asksum(int p, int l, int r) {\tif (s[p].r &lt; l || r &lt; s[p].l) return 0;\tif (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) return s[p].sum;\tpushdown(p);\treturn asksum(lson(p), l, r) + asksum(rson(p), l, r);}inline int askmax(int p, int l, int r) {\tif (s[p].r &lt; l || r &lt; s[p].l) return -INF;\tif (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) return s[p].max;\tpushdown(p);\treturn max(askmax(lson(p), l, r), askmax(rson(p), l, r));}inline int askmin(int p, int l, int r) {\tif (s[p].r &lt; l || r &lt; s[p].l) return INF;\tif (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) return s[p].min;\tpushdown(p);\treturn min(askmin(lson(p), l, r), askmin(rson(p), l, r));}inline void dfs1(int f, int u) {\tfa[u] = f, dep[u] = dep[f] + 1, siz[u] = 1;\tint tmp = -1;\tfor (auto e : g[u]) {\t\tint v = e.first;\t\tif (v == f) continue;\t\twssb[v] = e.second;\t\tdfs1(u, v);\t\tsiz[u] += siz[v];\t\tif (tmp &lt; siz[v]) {\t\t\tson[u] = v, tmp = siz[v];\t\t}\t}}inline void dfs2(int f, int u) {\tid[u] = ++cnt, w[cnt] = wssb[u], top[u] = f;\tif (son[u]) dfs2(f, son[u]);\tfor (auto e : g[u]) {\t\tint v = e.first;\t\tif (fa[u] == v || v == son[u]) continue;\t\tdfs2(v, v);\t}}inline void update1(int x, int k) {\tint ccf;\tif (dep[edge[x].first] &gt; dep[edge[x].second]) ccf = edge[x].first;\telse ccf = edge[x].second;\tchange1(1, id[ccf], k);}inline void update2(int x, int y) {\twhile (top[x] != top[y]) {\t\tif (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\t\tchange2(1, id[top[x]], id[x]);\t\tx = fa[top[x]];\t}\tif (dep[x] &gt; dep[y]) swap(x, y);\tif (x != y) change2(1, id[x] + 1, id[y]); //就是这里需要注意一下}inline int querysum(int x, int y) {\tint res = 0;\twhile (top[x] != top[y]) {\t\tif (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\t\tres += asksum(1, id[top[x]], id[x]);\t\tx = fa[top[x]];\t}\tif (dep[x] &gt; dep[y]) swap(x, y);\tif (x != y) res += asksum(1, id[x] + 1, id[y]); //就是这里需要注意一下\treturn res;}inline int querymax(int x, int y) {\tint res = -INF;\twhile (top[x] != top[y]) {\t\tif (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\t\tres = max(res, askmax(1, id[top[x]], id[x]));\t\tx = fa[top[x]];\t}\tif (dep[x] &gt; dep[y]) swap(x, y);\tif (x != y) res = max(res, askmax(1, id[x] + 1, id[y]));\treturn res;}inline int querymin(int x, int y) {\tint res = INF;\twhile (top[x] != top[y]) {\t\tif (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\t\tres = min(res, askmin(1, id[top[x]], id[x]));\t\tx = fa[top[x]];\t}\tif (dep[x] &gt; dep[y]) swap(x, y);\tif (x != y) res = min(res, askmin(1, id[x] + 1, id[y]));\treturn res;}signed main() {\tfst;\tcin &gt;&gt; n;\tfor (int i = 1; i &lt; n; i++) {\t\tint u, v, w;\t\tcin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\t\tu++, v++;\t\tg[u].push_back({v, w});\t\tg[v].push_back({u, w});\t\tedge[i] = {u, v};\t}\tdfs1(0, 1);\tdfs2(1, 1);\tbuild(1, 1, n);\tcin &gt;&gt; q;\twhile (q--) {\t\tstring op;\t\tint x, y;\t\tcin &gt;&gt; op &gt;&gt; x &gt;&gt; y;\t\tif (op == \"C\") {\t\t\tupdate1(x, y);\t\t} else if (op == \"N\") {\t\t\tx++, y++;\t\t\tupdate2(x, y);\t\t} else if (op == \"SUM\") {\t\t\tx++, y++;\t\t\tcout &lt;&lt; querysum(x, y) &lt;&lt; endl;\t\t} else if (op == \"MAX\") {\t\t\tx++, y++;\t\t\tcout &lt;&lt; querymax(x, y) &lt;&lt; endl;\t\t} else {\t\t\tx++, y++;\t\t\tcout &lt;&lt; querymin(x, y) &lt;&lt; endl;\t\t}\t}\treturn 0;}\n\nP3979P3979 遥远的国度 - 洛谷\n这个 trick 是个换根。\n随便找一个根节点搜出来。\n换根和路径操作直接换就行了。\n但是子树的话需要特殊注意一下。\n分类讨论，设当前查询的子树是 。当  为根时，跑全局，当根不在  的子树中是一样的，但是根在  的子树中，要除了根方向上的子树之外的所有节点。\n然后做完了。\n#include &lt;bits/stdc++.h&gt;using namespace std;#define debug cerr&lt;&lt;\"The code runs successfully.\\n\";#define endl '\\n'#define TRACE 1#define tcout TRACE &amp;&amp; cout#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);#define int long long#define lson(x) (x&lt;&lt;1)#define rson(x) (x&lt;&lt;1|1)const int P = 998244353;const int Base = 33331;const int INF = 0x3f3f3f3f3f3f3f3f;const int N = 1e5 + 10, M = 2e6 + 10;vector&lt;int&gt; g[N];struct segtree {\tint l, r, x, lazy;} s[N &lt;&lt; 2];int n, m, oldw[N], w[N], dep[N], id[N], top[N], fa[N], siz[N], son[N], rt, cnt;inline void calc(int p, int x) {\ts[p].x = x, s[p].lazy = x;}inline void pushup(int p) {\ts[p].x = min(s[lson(p)].x, s[rson(p)].x);}inline void pushdown(int p) {\tif (!s[p].lazy) return;\tcalc(lson(p), s[p].lazy), calc(rson(p), s[p].lazy);\ts[p].lazy = 0;}inline void build(int p, int l, int r) {\ts[p].l = l, s[p].r = r;\tif (l == r) {\t\ts[p].x = w[l];\t\treturn;\t}\tint mid = l + r &gt;&gt; 1;\tbuild(lson(p), l, mid);\tbuild(rson(p), mid + 1, r);\tpushup(p);}inline void modify(int p, int L, int R, int x) {\tif (s[p].l &gt; R || L &gt; s[p].r) return;\telse if (s[p].l &gt;= L &amp;&amp; s[p].r &lt;= R) {\t\tcalc(p, x);\t\treturn;\t}\tpushdown(p);\tmodify(lson(p), L, R, x);\tmodify(rson(p), L, R, x);\tpushup(p);}inline int ask(int p, int L, int R) {\tif (s[p].l &gt; R || L &gt; s[p].r) return INF;\telse if (s[p].l &gt;= L &amp;&amp; s[p].r &lt;= R) return s[p].x;\tpushdown(p);\treturn min(ask(lson(p), L, R), ask(rson(p), L, R));}inline int check(int u) {//check就是检查子树性质的\tif (rt == u) return 0;\telse if (id[rt] &lt;= id[u] || id[rt] &gt; id[u] + siz[u] - 1) {\t\treturn 1;\t} else return 2;}inline void dfs1(int f, int u) {\tfa[u] = f, dep[u] = dep[f] + 1, siz[u] = 1;\tint tmp = -1;\tfor (int v : g[u]) {\t\tif (v == f) continue;\t\tdfs1(u, v);\t\tsiz[u] += siz[v];\t\tif (siz[v] &gt; tmp) {\t\t\tson[u] = v;\t\t\ttmp = siz[v];\t\t}\t}}inline void dfs2(int tp, int u) {\ttop[u] = tp, id[u] = ++cnt, w[cnt] = oldw[u];\tif (son[u]) dfs2(tp, son[u]);\tfor (auto v : g[u]) {\t\tif (fa[u] == v || son[u] == v) continue;\t\tdfs2(v, v);\t}}inline void update(int x, int y, int k) {\t//debug;\twhile (top[x] != top[y]) {\t\t//debug;\t\tif (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\t\tmodify(1, id[top[x]], id[x], k);\t\tx = fa[top[x]];\t}\tif (dep[x] &gt; dep[y]) swap(x, y);\tmodify(1, id[x], id[y], k);}inline int query(int u) {\tint flg = check(u);\tif (flg == 0) return s[1].x; //全局\telse if (flg == 1) return ask(1, id[u], id[u] + siz[u] - 1); //直接做\telse {\t\t//debug;\t\t//这里就要特殊做了，按照上面的做\t\tint now = rt, sn = 0;\t\twhile (top[now] != top[u]) {\t\t\tif (fa[top[now]] == u) {\t\t\t\tsn = top[now];\t\t\t\tbreak;\t\t\t}\t\t\tnow = fa[top[now]];\t\t}\t\tif (!sn) sn = son[u];\t\tint ans = ask(1, 1, id[sn] - 1);\t\tif (id[sn] + siz[sn] - 1 != n) {\t\t\tans = min(ans, ask(1, id[sn] + siz[sn], n));\t\t}\t\treturn ans;\t}}signed main() {\tfst;\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 1; i &lt; n; i++) {\t\tint u, v;\t\tcin &gt;&gt; u &gt;&gt; v;\t\tg[u].push_back(v);\t\tg[v].push_back(u);\t}\tfor (int i = 1; i &lt;= n; i++) {\t\tcin &gt;&gt; oldw[i];\t}\tcin &gt;&gt; rt;\tdfs1(0, 1);\tdfs2(1, 1);\tbuild(1, 1, n);\tfor (int i = 1; i &lt;= m; i++) {\t\tint op;\t\tcin &gt;&gt; op;\t\tif (op == 1) {\t\t\tcin &gt;&gt; rt;\t\t} else if (op == 2) {\t\t\tint x, y, k;\t\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; k;\t\t\tupdate(x, y, k);\t\t} else {\t\t\tint x;\t\t\tcin &gt;&gt; x;\t\t\tcout &lt;&lt; query(x) &lt;&lt; endl;\t\t}\t}\treturn 0;}\n\nP5314P5314 [Ynoi2011] ODT - 洛谷\n第一道 Ynoi。\n节点值的维护是简单的，但是  小值不好做。\n最暴力的做法就是对于每个儿子都开一个普通平衡树，然后只能暴力修改，查询的的话把自己和父亲放进去就做完了。\n显然这是对于每个点都要修改，时间复杂度显然是不行的。\n考虑重链的性质。它只有顶端一个点是轻儿子，剩下的都是重儿子。\n所以如果普通平衡树只维护轻儿子，到了查询的时候把自己，父亲和重儿子加进去再弹出来就做完了。\n原本是需要维护七个重儿子来卡常的，但是我写的平板电视随便卡卡就过了。\n评测机波动正常，多交几发。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;using namespace __gnu_pbds;#define debug cerr&lt;&lt;\"The code runs successfully.\\n\";#define endl '\\n'#define TRACE 1#define tcout TRACE &amp;&amp; cout#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);#define fir first#define sec secondconst int P = 998244353;const int Base = 33331;#ifdef int\tconst int INF = 0x3f3f3f3f3f3f3f3f;#else\tconst int INF = 0x3f3f3f3f;#endifconst int N = 1e6 + 10, M = 1e6 + 10;#define re register#define getchar getchar_unlocked#define putchar putchar_unlockedinline int read() {\tre int x = 0;\tre char ch = getchar();\twhile (!isdigit(ch)) {\t\tch = getchar();\t}\twhile (isdigit(ch)) {\t\tx = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);\t\tch = getchar();\t}\treturn x ;}inline void write(int x) {\tif (x &gt; 9) write(x / 10);\tputchar((x % 10) ^ 48);}struct node {\tint x, id; //注意这里可能会被去重\tinline friend bool operator&lt;(node a, node b) {\t\tif (a.x == b.x) return a.id &lt; b.id;\t\treturn a.x &lt; b.x;\t}};tree&lt;node, null_type, less&lt;node&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; trr[N];vector&lt;int&gt; g[N];int w[N], n, q, tr[N], fa[N], dep[N], id[N], siz[N], top[N], son[N], cnt, dfn[N], u, v, ww, x, k, op;inline void add(int x, int k) {\tfor (; x &lt;= n; x += x &amp; -x) tr[x] += k;}inline int ask(int x) {\tre int res = 0;\tfor (; x; x ^= x &amp; -x) res += tr[x];\treturn res;}inline void dfs1(int f, int u) {\tfa[u] = f, dep[u] = dep[f] + 1, siz[u] = 1;\tfor (int v : g[u]) {\t\tif (v == f) continue;\t\tdfs1(u, v);\t\tsiz[u] += siz[v];\t\tif (siz[son[u]] &lt; siz[v]) son[u] = v;\t}}inline void dfs2(int t, int u) {\t//cerr&lt;&lt;u&lt;&lt;endl;\tid[u] = ++cnt, top[u] = t, dfn[cnt] = u;\tadd(id[u], w[u]);\tadd(id[u] + 1, -w[u]);\tif (son[u]) dfs2(t, son[u]);\tfor (int v : g[u]) {\t\tif (v == fa[u] || v == son[u]) continue;\t\t//exit(0);\t\tdfs2(v, v);\t\ttrr[u].insert({w[v], v});\t}}inline void update(int u, int v, int k) {\twhile (top[u] != top[v]) {\t\tif (dep[top[u]] &lt; dep[top[v]]) swap(u, v);\t\ttrr[fa[top[u]]].erase({w[top[u]], top[u]});\t\tadd(id[top[u]], k);\t\tadd(id[u] + 1, -k);\t\tw[top[u]] = ask(id[top[u]]);\t\ttrr[fa[top[u]]].insert({w[top[u]], top[u]});\t\tu = fa[top[u]];\t}\tif (dep[u] &gt; dep[v]) swap(u, v);\tadd(id[u], k);\tadd(id[v] + 1, -k);\tif (!fa[u] || dep[u] != dep[top[u]]) return; //只有轻儿子才能做\ttrr[fa[u]].erase({w[u], u});\tw[u] = ask(id[u]);\ttrr[fa[u]].insert({w[u], u});}inline int query(int x, int k) {\t//这里插入的时候一定要判断有没有，删除同理\ttrr[x].insert({ask(id[x]), x});\tif (fa[x]) trr[x].insert({ask(id[fa[x]]), fa[x]});\tif (son[x]) trr[x].insert({ask(id[son[x]]), son[x]});\tint ans = (*trr[x].find_by_order(k - 1)).x;\ttrr[x].erase({ask(id[x]), x});\tif (fa[x]) trr[x].erase({ask(id[fa[x]]), fa[x]});\tif (son[x]) trr[x].erase({ask(id[son[x]]), son[x]});\treturn ans;}signed main() {\t//fst;\tn = read(), q = read();\tfor (re int i = 1; i &lt;= n; ++i) w[i] = read();\tfor (re int i = 1; i &lt; n; ++i) {\t\tu = read(), v = read();\t\tg[u].push_back(v);\t\tg[v].push_back(u);\t}\tdfs1(0, 1);\tdfs2(1, 1);\twhile (q--) {\t\top = read();\t\tif (op == 1) {\t\t\tu = read(), v = read(), ww = read();\t\t\tupdate(u, v, ww);\t\t} else {\t\t\tx = read(), k = read();\t\t\twrite(query(x, k));\t\t\tputchar('\\n');\t\t}\t}\treturn 0;}\n\n\n完。\n","categories":["2025"],"tags":["算法·理论"]}]