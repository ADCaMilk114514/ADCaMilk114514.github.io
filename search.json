[{"title":"浅谈重链剖分","url":"/2025/09/29/%E6%B5%85%E8%B0%88%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86/","content":"浅谈重链剖分\n\n介绍重链剖分就是一些善（du）良（liu）出题人为了恶心我们加强难度，把序列上的问题转到树上的解决方案。具体方法就是把树分成一个个链，通过进行对链的修改实现对整棵树的修改。\n步骤DFS1第一次深度优先搜索维护出每个节点的深度父亲，子树大小，还有你的重链要往哪一个儿子走（简称重儿子）。  \n因为我们要让划分出的重链数量尽可能的少，所以说我们要挑子树最大的那个儿子作为重儿子。\n这样的话树上的每一条路径都能拆成不超过  条重链。\n因为如果向下经过轻边的话，所在子树大小至少会除以二。\nDFS2要想在把树划分成重链，显然不止这些。\n因为要对重链进行修改，所以说一条重链的节点编号必须是连续的。所以说要维护每个节点所在重链的顶端是谁（或者说是它属于哪一条重链），以及这个节点的新编号。\n最后根据编号将它维护到树形数据结构上。\n子树修改/查询最简单的一集。\n注意到子树内的编号都是连续的，所以直接对  进行操作。\n做完了。\n链上修改/查询类似一个求 LCA 的过程。\n当两个点不在同一条重链上的时候，就跳那个重链顶端深度更小的结点，对所在的重链进行修改。\n跳到同一条重链直接做就行了。\n时间复杂度显然是  的。\n例题P3384P3384 【模板】重链剖分/树链剖分 - 洛谷\n模板题，没啥好说的，按照上面的直接做就行了。\n#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define lowbit(x) (x&amp;-x)const int N = 1e5 + 10;int n, T, r, P, cnt, son[N], depth[N], fa[N], sz[N], id[N], top[N], w[N], c1[N], c2[N];vector&lt;int&gt; g[N];//---------这里是数据结构部分-------------inline void add(int l, int r, int x) {\tint ad1 = (l - 1) * x % P, ad2 = r *x % P;\tfor (int i = l; i &lt;= n; i += lowbit(i)) c1[i] = (c1[i] + x) % P, c2[i] = (c2[i] + ad1) % P;\tfor (int i = r + 1; i &lt;= n; i += lowbit(i)) c1[i] = (c1[i] - x + P) % P, c2[i] = (c2[i] - ad2 + P) % P;}inline int query(int x) {\tint ret = 0;\tfor (int i = x; i; i -= lowbit(i)) ret = (ret + c1[i] * x % P) % P, ret = (ret - c2[i] + P) % P;\treturn ret;}inline int ask(int l, int r) {\treturn (query(r) - query(l - 1) + P) % P;}//---------这里是树剖部分----------//dfs基本上都是千篇一律，直接背就行inline void dfs1(int f, int u) {\tfa[u] = f, sz[u] = 1, depth[u] = depth[f] + 1;\tint tmp = -1;\tfor (int v : g[u]) {\t\tif (v == f) continue;\t\tdfs1(u, v);\t\tsz[u] += sz[v];\t\tif (sz[v] &gt; tmp) tmp = sz[v], son[u] = v;\t}}inline void dfs2(int f, int u) {\ttop[u] = f, id[u] = ++cnt;\tadd(id[u], id[u], w[u]);\tif (son[u] == 0) return;\tdfs2(f, son[u]);\tfor (int v : g[u]) {\t\tif (v == fa[u] || v == son[u]) continue;\t\tdfs2(v, v);\t}}//这里是路径，不同的题可能略有修改inline void addPath(int u, int v, int k) {\tk %= P;\twhile (top[u] != top[v]) {\t\tif (depth[top[u]] &lt; depth[top[v]]) swap(u, v); //LCA 显然是优先跳小的\t\tadd(id[top[u]], id[u], k);\t\tu = fa[top[u]];\t}\tif (depth[u] &gt; depth[v]) swap(u, v); //深度大的在后\tadd(id[u], id[v], k);}//和addPath一样就不讲了inline int askPath(int u, int v) {\tint res = 0;\twhile (top[u] != top[v]) {\t\tif (depth[top[u]] &lt; depth[top[v]]) swap(u, v);\t\tres = (res + ask(id[top[u]], id[u])) % P, u = fa[top[u]];\t}\tif (depth[u] &gt; depth[v]) swap(u, v);\tres = (res + ask(id[u], id[v])) % P;\treturn res;}//子树没啥好讲的inline int askSon(int u) {\treturn ask(id[u], id[u] + sz[u] - 1);}inline void addSon(int u, int k) {\tk %= P;\tadd(id[u], id[u] + sz[u] - 1, k);}//---------这里是主函数部分----------signed main() {\tcin &gt;&gt; n &gt;&gt; T &gt;&gt; r &gt;&gt; P;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\tfor (int i = 1; i &lt; n; i++) {\t\tint u, v;\t\tcin &gt;&gt; u &gt;&gt; v;\t\tg[u].push_back(v);\t\tg[v].push_back(u);\t}\tdfs1(0, r), dfs2(r, r);\tint op, u, v, k;\twhile (T--) {\t\tcin &gt;&gt; op &gt;&gt; u;\t\tif (op == 1) {\t\t\tcin &gt;&gt; v &gt;&gt; k;\t\t\taddPath(u, v, k);\t\t} else if (op == 2) {\t\t\tcin &gt;&gt; v;\t\t\tcout &lt;&lt; askPath(u, v) &lt;&lt; endl;\t\t} else if (op == 3) {\t\t\tcin &gt;&gt; k;\t\t\taddSon(u, k);\t\t} else {\t\t\tcout &lt;&lt; askSon(u) &lt;&lt; endl;\t\t}\t}\treturn 0;}\n\nP1505P1505 [国家集训队] 旅游 - 洛谷\n也是几乎板子，线段树稍微改一改。\n但是这里有一个 trick 就是边权转点权。\n对于每一条边，把它的边权转移到通向的深度更大的点。\n这里有一个细节，进行链上修改的时候，跳到了同一条重链，这个时候深度更小的点的点权是不会进行修改的，然后就可以直接做了。\n毒瘤题目的下标是从零开始的。\n#include &lt;bits/stdc++.h&gt;using namespace std;#define debug cerr&lt;&lt;\"The code runs successfully.\\n\";#define endl '\\n'#define TRACE 1#define tcout TRACE &amp;&amp; cout#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);#define int long long#define lson(x) (x&lt;&lt;1)#define rson(x) (x&lt;&lt;1|1)const int P = 998244353;const int Base = 33331;const int INF = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10, M = 2e6 + 10;struct segtree {\tint l, r, sum, max, min, lazy;} s[N &lt;&lt; 2];pair&lt;int, int&gt; edge[N];vector&lt;pair&lt;int, int&gt;&gt; g[N];int n, q, id[N], cnt, son[N], siz[N], fa[N], w[N], top[N], dep[N], wssb[N];inline void calc(int p) {\ts[p].lazy ^= 1;\ts[p].sum = -s[p].sum;\ts[p].max = -s[p].max;\ts[p].min = -s[p].min;\tswap(s[p].max, s[p].min);}inline void pushup(int p) {\ts[p].sum = s[lson(p)].sum + s[rson(p)].sum;\ts[p].min = min(s[lson(p)].min, s[rson(p)].min);\ts[p].max = max(s[lson(p)].max, s[rson(p)].max);}inline void pushdown(int p) {\tif (!s[p].lazy) return;\tcalc(lson(p)), calc(rson(p));\ts[p].lazy ^= 1;}inline void build(int p, int l, int r) {\ts[p].l = l, s[p].r = r;\tif (l == r) {\t\ts[p].sum = s[p].min = s[p].max = w[l];\t\treturn;\t}\tint mid = l + r &gt;&gt; 1;\tbuild(lson(p), l, mid);\tbuild(rson(p), mid + 1, r);\tpushup(p);}inline void change1(int p, int x, int k) {\tif (s[p].l == s[p].r) {\t\ts[p].sum = s[p].max = s[p].min = k;\t\treturn;\t}\tpushdown(p);\tint mid = s[p].l + s[p].r &gt;&gt; 1;\tif (mid &gt;= x) change1(lson(p), x, k);\telse change1(rson(p), x, k);\tpushup(p);}inline void change2(int p, int l, int r) {\tif (s[p].r &lt; l || r &lt; s[p].l) return;\tif (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) {\t\tcalc(p);\t\treturn;\t}\tpushdown(p);\tint mid = s[p].l + s[p].r &gt;&gt; 1;\tchange2(lson(p), l, r), change2(rson(p), l, r);\tpushup(p);}inline int asksum(int p, int l, int r) {\tif (s[p].r &lt; l || r &lt; s[p].l) return 0;\tif (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) return s[p].sum;\tpushdown(p);\treturn asksum(lson(p), l, r) + asksum(rson(p), l, r);}inline int askmax(int p, int l, int r) {\tif (s[p].r &lt; l || r &lt; s[p].l) return -INF;\tif (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) return s[p].max;\tpushdown(p);\treturn max(askmax(lson(p), l, r), askmax(rson(p), l, r));}inline int askmin(int p, int l, int r) {\tif (s[p].r &lt; l || r &lt; s[p].l) return INF;\tif (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) return s[p].min;\tpushdown(p);\treturn min(askmin(lson(p), l, r), askmin(rson(p), l, r));}inline void dfs1(int f, int u) {\tfa[u] = f, dep[u] = dep[f] + 1, siz[u] = 1;\tint tmp = -1;\tfor (auto e : g[u]) {\t\tint v = e.first;\t\tif (v == f) continue;\t\twssb[v] = e.second;\t\tdfs1(u, v);\t\tsiz[u] += siz[v];\t\tif (tmp &lt; siz[v]) {\t\t\tson[u] = v, tmp = siz[v];\t\t}\t}}inline void dfs2(int f, int u) {\tid[u] = ++cnt, w[cnt] = wssb[u], top[u] = f;\tif (son[u]) dfs2(f, son[u]);\tfor (auto e : g[u]) {\t\tint v = e.first;\t\tif (fa[u] == v || v == son[u]) continue;\t\tdfs2(v, v);\t}}inline void update1(int x, int k) {\tint ccf;\tif (dep[edge[x].first] &gt; dep[edge[x].second]) ccf = edge[x].first;\telse ccf = edge[x].second;\tchange1(1, id[ccf], k);}inline void update2(int x, int y) {\twhile (top[x] != top[y]) {\t\tif (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\t\tchange2(1, id[top[x]], id[x]);\t\tx = fa[top[x]];\t}\tif (dep[x] &gt; dep[y]) swap(x, y);\tif (x != y) change2(1, id[x] + 1, id[y]); //就是这里需要注意一下}inline int querysum(int x, int y) {\tint res = 0;\twhile (top[x] != top[y]) {\t\tif (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\t\tres += asksum(1, id[top[x]], id[x]);\t\tx = fa[top[x]];\t}\tif (dep[x] &gt; dep[y]) swap(x, y);\tif (x != y) res += asksum(1, id[x] + 1, id[y]); //就是这里需要注意一下\treturn res;}inline int querymax(int x, int y) {\tint res = -INF;\twhile (top[x] != top[y]) {\t\tif (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\t\tres = max(res, askmax(1, id[top[x]], id[x]));\t\tx = fa[top[x]];\t}\tif (dep[x] &gt; dep[y]) swap(x, y);\tif (x != y) res = max(res, askmax(1, id[x] + 1, id[y]));\treturn res;}inline int querymin(int x, int y) {\tint res = INF;\twhile (top[x] != top[y]) {\t\tif (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\t\tres = min(res, askmin(1, id[top[x]], id[x]));\t\tx = fa[top[x]];\t}\tif (dep[x] &gt; dep[y]) swap(x, y);\tif (x != y) res = min(res, askmin(1, id[x] + 1, id[y]));\treturn res;}signed main() {\tfst;\tcin &gt;&gt; n;\tfor (int i = 1; i &lt; n; i++) {\t\tint u, v, w;\t\tcin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\t\tu++, v++;\t\tg[u].push_back({v, w});\t\tg[v].push_back({u, w});\t\tedge[i] = {u, v};\t}\tdfs1(0, 1);\tdfs2(1, 1);\tbuild(1, 1, n);\tcin &gt;&gt; q;\twhile (q--) {\t\tstring op;\t\tint x, y;\t\tcin &gt;&gt; op &gt;&gt; x &gt;&gt; y;\t\tif (op == \"C\") {\t\t\tupdate1(x, y);\t\t} else if (op == \"N\") {\t\t\tx++, y++;\t\t\tupdate2(x, y);\t\t} else if (op == \"SUM\") {\t\t\tx++, y++;\t\t\tcout &lt;&lt; querysum(x, y) &lt;&lt; endl;\t\t} else if (op == \"MAX\") {\t\t\tx++, y++;\t\t\tcout &lt;&lt; querymax(x, y) &lt;&lt; endl;\t\t} else {\t\t\tx++, y++;\t\t\tcout &lt;&lt; querymin(x, y) &lt;&lt; endl;\t\t}\t}\treturn 0;}\n\nP3979P3979 遥远的国度 - 洛谷\n这个 trick 是个换根。\n随便找一个根节点搜出来。\n换根和路径操作直接换就行了。\n但是子树的话需要特殊注意一下。\n分类讨论，设当前查询的子树是 。当  为根时，跑全局，当根不在  的子树中是一样的，但是根在  的子树中，要除了根方向上的子树之外的所有节点。\n然后做完了。\n#include &lt;bits/stdc++.h&gt;using namespace std;#define debug cerr&lt;&lt;\"The code runs successfully.\\n\";#define endl '\\n'#define TRACE 1#define tcout TRACE &amp;&amp; cout#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);#define int long long#define lson(x) (x&lt;&lt;1)#define rson(x) (x&lt;&lt;1|1)const int P = 998244353;const int Base = 33331;const int INF = 0x3f3f3f3f3f3f3f3f;const int N = 1e5 + 10, M = 2e6 + 10;vector&lt;int&gt; g[N];struct segtree {\tint l, r, x, lazy;} s[N &lt;&lt; 2];int n, m, oldw[N], w[N], dep[N], id[N], top[N], fa[N], siz[N], son[N], rt, cnt;inline void calc(int p, int x) {\ts[p].x = x, s[p].lazy = x;}inline void pushup(int p) {\ts[p].x = min(s[lson(p)].x, s[rson(p)].x);}inline void pushdown(int p) {\tif (!s[p].lazy) return;\tcalc(lson(p), s[p].lazy), calc(rson(p), s[p].lazy);\ts[p].lazy = 0;}inline void build(int p, int l, int r) {\ts[p].l = l, s[p].r = r;\tif (l == r) {\t\ts[p].x = w[l];\t\treturn;\t}\tint mid = l + r &gt;&gt; 1;\tbuild(lson(p), l, mid);\tbuild(rson(p), mid + 1, r);\tpushup(p);}inline void modify(int p, int L, int R, int x) {\tif (s[p].l &gt; R || L &gt; s[p].r) return;\telse if (s[p].l &gt;= L &amp;&amp; s[p].r &lt;= R) {\t\tcalc(p, x);\t\treturn;\t}\tpushdown(p);\tmodify(lson(p), L, R, x);\tmodify(rson(p), L, R, x);\tpushup(p);}inline int ask(int p, int L, int R) {\tif (s[p].l &gt; R || L &gt; s[p].r) return INF;\telse if (s[p].l &gt;= L &amp;&amp; s[p].r &lt;= R) return s[p].x;\tpushdown(p);\treturn min(ask(lson(p), L, R), ask(rson(p), L, R));}inline int check(int u) {//check就是检查子树性质的\tif (rt == u) return 0;\telse if (id[rt] &lt;= id[u] || id[rt] &gt; id[u] + siz[u] - 1) {\t\treturn 1;\t} else return 2;}inline void dfs1(int f, int u) {\tfa[u] = f, dep[u] = dep[f] + 1, siz[u] = 1;\tint tmp = -1;\tfor (int v : g[u]) {\t\tif (v == f) continue;\t\tdfs1(u, v);\t\tsiz[u] += siz[v];\t\tif (siz[v] &gt; tmp) {\t\t\tson[u] = v;\t\t\ttmp = siz[v];\t\t}\t}}inline void dfs2(int tp, int u) {\ttop[u] = tp, id[u] = ++cnt, w[cnt] = oldw[u];\tif (son[u]) dfs2(tp, son[u]);\tfor (auto v : g[u]) {\t\tif (fa[u] == v || son[u] == v) continue;\t\tdfs2(v, v);\t}}inline void update(int x, int y, int k) {\t//debug;\twhile (top[x] != top[y]) {\t\t//debug;\t\tif (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\t\tmodify(1, id[top[x]], id[x], k);\t\tx = fa[top[x]];\t}\tif (dep[x] &gt; dep[y]) swap(x, y);\tmodify(1, id[x], id[y], k);}inline int query(int u) {\tint flg = check(u);\tif (flg == 0) return s[1].x; //全局\telse if (flg == 1) return ask(1, id[u], id[u] + siz[u] - 1); //直接做\telse {\t\t//debug;\t\t//这里就要特殊做了，按照上面的做\t\tint now = rt, sn = 0;\t\twhile (top[now] != top[u]) {\t\t\tif (fa[top[now]] == u) {\t\t\t\tsn = top[now];\t\t\t\tbreak;\t\t\t}\t\t\tnow = fa[top[now]];\t\t}\t\tif (!sn) sn = son[u];\t\tint ans = ask(1, 1, id[sn] - 1);\t\tif (id[sn] + siz[sn] - 1 != n) {\t\t\tans = min(ans, ask(1, id[sn] + siz[sn], n));\t\t}\t\treturn ans;\t}}signed main() {\tfst;\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 1; i &lt; n; i++) {\t\tint u, v;\t\tcin &gt;&gt; u &gt;&gt; v;\t\tg[u].push_back(v);\t\tg[v].push_back(u);\t}\tfor (int i = 1; i &lt;= n; i++) {\t\tcin &gt;&gt; oldw[i];\t}\tcin &gt;&gt; rt;\tdfs1(0, 1);\tdfs2(1, 1);\tbuild(1, 1, n);\tfor (int i = 1; i &lt;= m; i++) {\t\tint op;\t\tcin &gt;&gt; op;\t\tif (op == 1) {\t\t\tcin &gt;&gt; rt;\t\t} else if (op == 2) {\t\t\tint x, y, k;\t\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; k;\t\t\tupdate(x, y, k);\t\t} else {\t\t\tint x;\t\t\tcin &gt;&gt; x;\t\t\tcout &lt;&lt; query(x) &lt;&lt; endl;\t\t}\t}\treturn 0;}\n\nP5314P5314 [Ynoi2011] ODT - 洛谷\n第一道 Ynoi。\n节点值的维护是简单的，但是  小值不好做。\n最暴力的做法就是对于每个儿子都开一个普通平衡树，然后只能暴力修改，查询的的话把自己和父亲放进去就做完了。\n显然这是对于每个点都要修改，时间复杂度显然是不行的。\n考虑重链的性质。它只有顶端一个点是轻儿子，剩下的都是重儿子。\n所以如果普通平衡树只维护轻儿子，到了查询的时候把自己，父亲和重儿子加进去再弹出来就做完了。\n原本是需要维护七个重儿子来卡常的，但是我写的平板电视随便卡卡就过了。\n评测机波动正常，多交几发。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;using namespace __gnu_pbds;#define debug cerr&lt;&lt;\"The code runs successfully.\\n\";#define endl '\\n'#define TRACE 1#define tcout TRACE &amp;&amp; cout#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);#define fir first#define sec secondconst int P = 998244353;const int Base = 33331;#ifdef int\tconst int INF = 0x3f3f3f3f3f3f3f3f;#else\tconst int INF = 0x3f3f3f3f;#endifconst int N = 1e6 + 10, M = 1e6 + 10;#define re register#define getchar getchar_unlocked#define putchar putchar_unlockedinline int read() {\tre int x = 0;\tre char ch = getchar();\twhile (!isdigit(ch)) {\t\tch = getchar();\t}\twhile (isdigit(ch)) {\t\tx = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);\t\tch = getchar();\t}\treturn x ;}inline void write(int x) {\tif (x &gt; 9) write(x / 10);\tputchar((x % 10) ^ 48);}struct node {\tint x, id; //注意这里可能会被去重\tinline friend bool operator&lt;(node a, node b) {\t\tif (a.x == b.x) return a.id &lt; b.id;\t\treturn a.x &lt; b.x;\t}};tree&lt;node, null_type, less&lt;node&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; trr[N];vector&lt;int&gt; g[N];int w[N], n, q, tr[N], fa[N], dep[N], id[N], siz[N], top[N], son[N], cnt, dfn[N], u, v, ww, x, k, op;inline void add(int x, int k) {\tfor (; x &lt;= n; x += x &amp; -x) tr[x] += k;}inline int ask(int x) {\tre int res = 0;\tfor (; x; x ^= x &amp; -x) res += tr[x];\treturn res;}inline void dfs1(int f, int u) {\tfa[u] = f, dep[u] = dep[f] + 1, siz[u] = 1;\tfor (int v : g[u]) {\t\tif (v == f) continue;\t\tdfs1(u, v);\t\tsiz[u] += siz[v];\t\tif (siz[son[u]] &lt; siz[v]) son[u] = v;\t}}inline void dfs2(int t, int u) {\t//cerr&lt;&lt;u&lt;&lt;endl;\tid[u] = ++cnt, top[u] = t, dfn[cnt] = u;\tadd(id[u], w[u]);\tadd(id[u] + 1, -w[u]);\tif (son[u]) dfs2(t, son[u]);\tfor (int v : g[u]) {\t\tif (v == fa[u] || v == son[u]) continue;\t\t//exit(0);\t\tdfs2(v, v);\t\ttrr[u].insert({w[v], v});\t}}inline void update(int u, int v, int k) {\twhile (top[u] != top[v]) {\t\tif (dep[top[u]] &lt; dep[top[v]]) swap(u, v);\t\ttrr[fa[top[u]]].erase({w[top[u]], top[u]});\t\tadd(id[top[u]], k);\t\tadd(id[u] + 1, -k);\t\tw[top[u]] = ask(id[top[u]]);\t\ttrr[fa[top[u]]].insert({w[top[u]], top[u]});\t\tu = fa[top[u]];\t}\tif (dep[u] &gt; dep[v]) swap(u, v);\tadd(id[u], k);\tadd(id[v] + 1, -k);\tif (!fa[u] || dep[u] != dep[top[u]]) return; //只有轻儿子才能做\ttrr[fa[u]].erase({w[u], u});\tw[u] = ask(id[u]);\ttrr[fa[u]].insert({w[u], u});}inline int query(int x, int k) {\t//这里插入的时候一定要判断有没有，删除同理\ttrr[x].insert({ask(id[x]), x});\tif (fa[x]) trr[x].insert({ask(id[fa[x]]), fa[x]});\tif (son[x]) trr[x].insert({ask(id[son[x]]), son[x]});\tint ans = (*trr[x].find_by_order(k - 1)).x;\ttrr[x].erase({ask(id[x]), x});\tif (fa[x]) trr[x].erase({ask(id[fa[x]]), fa[x]});\tif (son[x]) trr[x].erase({ask(id[son[x]]), son[x]});\treturn ans;}signed main() {\t//fst;\tn = read(), q = read();\tfor (re int i = 1; i &lt;= n; ++i) w[i] = read();\tfor (re int i = 1; i &lt; n; ++i) {\t\tu = read(), v = read();\t\tg[u].push_back(v);\t\tg[v].push_back(u);\t}\tdfs1(0, 1);\tdfs2(1, 1);\twhile (q--) {\t\top = read();\t\tif (op == 1) {\t\t\tu = read(), v = read(), ww = read();\t\t\tupdate(u, v, ww);\t\t} else {\t\t\tx = read(), k = read();\t\t\twrite(query(x, k));\t\t\tputchar('\\n');\t\t}\t}\treturn 0;}\n\n\n完。\n","categories":["2025"],"tags":["算法·理论"]},{"title":"测试","url":"/2025/09/02/%E6%B5%8B%E8%AF%95/","content":"\n\n\n\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main() {    int a,b;    cin&gt;&gt;a&gt;&gt;b;    cout&lt;&lt;a+b&lt;&lt;endl;    return 0;}\n\nios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\n你好。\n\n首页 - 洛谷 | 计算机科学教育新生态\n123456\n\n\n1\n1\n1\n\n\n\n2\n2\n2\n\n\n3\n3\n3\n\n\n4\n4\n4\n\n\n\n1\n2\n3\n4\n\naaa\naaa\n11111\n\nawa\nqwq\npwp\nqaq\n\n","categories":["2025"],"tags":["科技·工程"]},{"title":"训练记录","url":"/2025/10/21/%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/","content":"训练记录\n\n25.10.7比赛总结T120min写了个二分答案发现假了，又花20min写了个新的。 \n给你一个长度为  的序列，问你所有长度为  的子段的  的最小值。\n题解里面是  的，但是我大暴力直接过了。\n用树状数组维护数字是否存在，如果说滑动窗口里有这个数字就是 ，否则就是 ，这个每次是可以  维护的。（这里要加上一个数因为  无法被树状数组维护）  \n对于每一个滑动窗口二分  如果说树状数组中前缀和是区间长度的话前前面就不可取，否则往前走就行了。\n每次二分是  的（ 为值域），总复杂度就是  的，能过。\n不足就是没有完全验证解法的正确性，以后还是要三思而后行。\nT2赛时5min打了全暴力，不懂为什么和别人的暴力得分不一样。\n给你一个数 ，让你找出字典序最小的有序整数对 ，满足  且 。\n咋是暴力啊。\n根据区间长度进行大分讨。\n\n长度为  只能是原数。\n长度为  的话最小公倍数应该是 。\n长度为  或更大的话直接预处理出来然后直接计算就做完了。\n\n不足就是暴力没有优化，下次记得剪枝（流泪）\nT3根本不会，输出  赛后测是三分。\n让你选出一个图的子图，使得有一个点的度数小于 ，并最大化点的个数。\n不会做了。\n25.10.8比赛总结T1赛时想到了  的做法，预计能得  分，但是由于评测机问题值得了  分，用时一小时。\n题意是有  个工人，一个工人在  单位时间中能做  个零件，最多招  个工人，总时间是几个工人中的最大值，问你做  个零件至少需要多少时间。\n可以二分所需的时间，每个工人能做多少零件是确定的，我们挑最大的  个加起来判断就行了。朴素找最大应该是  的，不能过，但是这里有一个函数叫 nth_element，可以返回数组的第  大，但是实际上它会将数组的前  大都放在前面，时间复杂度单次 ，可以接受。\n感觉没什么不足啊，已经尽力了，这种特殊功能真没有接触过，还是对 STL 的理解不过深入。\nT2赛时 AC，感觉比 T1 简单，用时一个半小时。\n一棵树，点可以是黑色，白色，和无色，要求是黑点和白点不能在同一条边上，两个颜色都要有，而且涂色点的数量尽可能多。换句话说，能涂色的点一定要涂。\n问你涂色方案数 。\n因为涂色点的数量尽可能多，显然是  个点，一个点无色作为分隔，剩下的涂什么都可以。\n对于每个点，假设它的度是 ，那么它是无色的方案数即为 ，最后累加就行了。\n不足就是思考不够深入，没有从原题的条件进行进一步推导，然后很久才出结论。\nT3赛时用十分钟打了暴力得了三十分。\n题意简单是有几段单调递增  的序列形成一个环，问你长度为  的子段最大和是多少。\n取得的元素可以分为整段和零段，只考虑整段的话，零段往左取最好，因为左边递减，一定更优，也就是说，右端点一定是一个整段的结尾，然后可以二分左端点，二分出来直接计算就做完了。\n思考不够深入，要是瞪不出来结论直接猜也有可能是对的，所以以后像这种结论题一定好好猜一猜才行。\nT4完全不会。\n题意读不懂，暴力也没打。\nT5赛时打了个暴力算错复杂度结果炸了没得分。\n题意是一棵树删掉一条边两边的颜色数量之和。\n赛后有了一种与题解不同的做法。\n考虑将颜色段维护到 DFS 序上，因为删掉一条边之后树变成了一个子树和剩下的，在 DFS 序上就是一个连续的区间和和左边一段和右面一段，开两倍空间就是一个连续段。这样只需要维护区间颜色树就行了，这里有几种可能的方法：\n\nODT\n树状数组（离线）\n莫队（离线）\n主席树\n分块\n\n这里我挑了最好写而且时间复杂度低的树状数组，因为只有  次询问，所以离线下来是可行的。\n这里失误了，没有估算时间复杂度（但是我赛后算的是可以的，不得不说评测机真慢）。\n25.10.12比赛总结T1赛时因为读错题浪费了十几分钟。然后重新看发现读错题了很好想，五分钟写了一下就交了。\n预估：\n实际：\n题意给你一个数，两个人轮流将这个数变成这个数除本身和  之外的一个因数，最后无法操作的人获胜。\n思路获胜的方式显然是拿到了  或者质数。根据定义， 只可能先手第一个拿到，所以说可以考虑除  以外质因数因数的个数（相同的质因数按个数统计）。\n\n因数为  时是质数，先手必胜。\n因数为  时先手必须拿走一个，后手只剩一个，后手必胜。\n因数比  大的时候先手可以一次拿到只剩两个质因数，这时后手的情况和上一种先手的情况是一样的，翻转过来就是先手必胜。、\n\nT2赛时观察到了很经典的结论，发现复杂度是对的，花十几分钟写了一下就做完了。\n预估：\n实际：\n题意构造一个数列 ，长度为 ,满足 ，并且至少存在  个 ，使得 。\n问的是方案数对  取模。\n思路题目中  很大完全是诈骗，因为最多只会存在  个满足条件。而且根据这个数列的大小约束，从一个余数变到另一个余数有且仅有一种方案。\n所以可以枚举  的数量，剩下的都填 ，所以说答案就是：\nT3赛时看了一眼想到了暴力，但是发现不好写，而且复杂度拿不到分，所以说就想输出无解试一下。\n预估：\n实际：\n考虑到上次梦熊比赛没有无解的数据我就没敢多估。\n题意给一个无向连通图，要求从  到  的最短路不能超过 ，从  到  的最短路不能超过 ，并最大化删边的数量。\n思路赛时以为有权值被吓哭了，没有权值好简单。\n首先用 BFS 跑出全源最短路来，然后就可以判无解。因为要删掉的边最多，所以两个路径一定有公共部分，枚举中间的公共部分，然后答案直接算。\n有两个小细节，一个就是提前考虑不公共直接减去，还有就是两条路径的方向可能是相反的。\nT4赛时想到了时间复杂度分析中一个很常见的式子，发现在这里能用，写了一百多行的屎山，调了二十多分钟就交了。\n预估：\n实际：\n题意数列  初始全为 ， 是  到  的一个排列，实现两种操作：\n\n1 l r 将  全部加 。\n2 l r 查询  的值。\n\n思路首先有一个非常常见的结论：也就是说我们的答案最多执行这些次加一。\n我们用线段树维护出一个区间最多还要加几次  才能让区间和加上 ，对于每次加一，如果说这个值等于  就直接递归下去修改，否则直接存在懒标记里面，查询和普通的线段树一样做就行了。\n根据上面的结论，复杂度最多是  的，能过。\nT5赛时打暴力挺简单的，花了我十五分钟。\n预估：\n实际：\n题意一个图有一些边，每条边有一个概率出现，求最小生成树的期望。\n思路我不会。讲一下暴力。\n就是枚举哪些边会被加进去然后计算最小生成树统计就行了。\n25.10.19比赛总结T1赛时写了个暴力找了找规律，找到规律之后写了个带  的做法，后面发现可以优化，很好改，耗时两个小时。\n估分：\n实际：\n题意一个数列，让你求出所有长度为  的子段中最大值中的最小值。\n思路一个数是这个区间的最大值当且仅当左右都没有比他大的。\n对于每个数，单调栈维护出左右比他大的第一个数，就得到了这个东西对答案做出的贡献。\n我们只考虑最大长度下他的答案。\n因为答案一定是单调不降的，最后取后缀最小值就行了。\n代码很好写。\nT2赛时想到了一个 Trie 的做法发现假完了，所以写了个暴力，耗时半小时。\n估分：\n实际：\n题意一个图， 能到  仅当有连边或 ，问你从  开始的单源最短路径。\n思路首先要知道按位与这种东西是可以传递的。\n可以考虑建第二个图，将一个权值能到达的另一个权值都连上权值为  的边，因为这个东西具有传递性，所以连边可以只连二进制下只有一位只差的权值，以减少连边的数量。\n然后将点的编号与权值连上权为  的边，反向连的是权值为  的边。\n考虑到权值只有  和  可以双向 BFS 求最短路。\nT3赛时发现暴力都不会打，很难写，所以不可以总司令。\n预估：\n实际：\n题意一个数列，其中  出现  次，问你有哪些排列方式满足可以划分为不超过  个单调递增的子段，对于每一个  分别求解。\n思路先口胡一下。\n补完了，不是口胡了。\n令  表示前  小个数构成至少  个段的方案数，显然一组数放在段后是不会增加段数的，可以去枚举增加的段数去计算这样的排列方式。\n正难则反，可以用总方案数减去不能行的方案数。\n可以用插板法来解决。\n第一维可以被压掉。\nT4赛时看一眼题发现暴力很好打，打了个暴力花了二十分钟。\n预估：\n实际：\n题意给你一个数 ，令  表示  的因子中与另外一个因子互质的数的个数，求 。\n思路题解做麻烦了。\n题意可以简化为找整数对  使得  并且  的数量。\n令 ，因为平方根一定不满足条件，所以算出来直接将答案乘二就行了。\n可以枚举 ，计算它的贡献，具体方法是进行质因数分解，特判掉 ，然后看看有多少个数和它互质，因为质因数个数很小只有  所以可以直接容斥。\n25.10.20做题记录策略游戏题意两个数列，前者在一个序列的区间中选数，后者在另外一个序列的区间中选数，得分为乘积。前者希望得分尽可能大，后者希望得分尽可能小，求得分。\n思路很恶心的大分讨。\n用  分钟去想贪心发现有负数不可做，考虑了一下分类讨论的去贪心，一共有  中情况，代码难度偏高，花了将近一个小时。\n这里列一个表格来枚举两种人的情况。\n\n\n\n\n先手没有负数\n先手没有正数\n先手都有\n\n\n\n后手没有负数\n先手最大 后手最小\n先手最大 后手最小\n先手最大 后手最小\n\n\n后手没有正数\n先手最小 后手最大\n先手最小 后手最大\n先手最小 后手最大\n\n\n后手都有\n先手最小 后手最小\n先手最大 后手最大\n如果先手有  一定取，否则就是对同号的情况取最大值\n\n\n可以用 ST 表或者线段树维护这些内容。\n动物园题意有一些动物，其中二进制编号决定的需要的饲料，问你最多增加多少动物使得饲料数量是不变的。\n思路看完题马上会了，但是因为细节问题硬控半个多小时。\n因为决定的饲料一定不相同，所以说可以直接把可以要的位数计算下来，最后减去已经有的方案数，也就是  种方案。\n需要 __int128。\n星战题意一个 DAG，进行几种操作：\n\n删除一条原来有的边\n删除一个点（删除所有连向这个点的边）\n恢复原来的一条边\n恢复原来的一个点（恢复所有连向这个点的边）\n\n问每次操作后，能否满足所有点的出度为  ，并且从任意一个点出发可以走到一个环中。\n思路看完题解和 aa 的代码会的，感觉代码不是非常难，写了写会了，三十分钟左右。\n\n不可以，总司令。——沃·兹基\n\n其实根本不用判断环，只需要判断度数。因为有 Wiki 上的结论：\n如果一个有向图每个点的出度都为 ，称它是一个 基环内向森林。\n顾名思义，从每个点出发都可以走到一个环上。\n问题就变成的维护点的度数。\n可以对于每个点随机一个权值 ，令  表示当前所有连向  的点的权值和，这个东西是可以  来维护的。因为每次只会修改一个值，所以， 也是可以维护的。\n因为是随机权值，所以我们的目标状态可以看作是：做完了。\n消消乐题意一个字符串 ，如果相邻的字符相同可以删除，问你有多少子段满足能够全部删完。\n思路想到了括号匹配，后面不大会了。看的题解，代码很短。一个小时左右。\n这个题完全可以看作括号匹配。\n设  表示以  为结尾的合法串的方案数，我们找到上一个使它成为合法子串的下标（字符一定相同），这样就在原来的基础上多了一种方案数。\n去维护下标减一，这样就会形成链，所以每次查询是  的。 \n最后答案是 。\n染色题意一个数列染成蓝色和红色，每个点有权值。\n如果说一个颜色前面第一个同颜色的值和它的相同，就将答案加上这个值。\n求最后的答案最大值。\n思路看了题解，听了同学讲，再去理解一下，耗时一个小时多。\n贪心显然不行，考虑 DP。\n令  为考虑到第  位的答案最大。\n显然可以转化为 。\n要想答案最大，一定要进行匹配。那就是上一个出现的下标往前加上中间匹配的成果再加上这两个的值。\n要是中间匹配可以前缀和维护。\n做完了。\n25.10.21比赛总结T1赛时想了个思路，写出来之后发现假完了。然后发现正确的思路和原来差不多，然后改了改就对了，用时一个小时。\n估分：\n实际：\n话说多测不清空不应该只挂这么点的。\n题意一棵树，一个图。图中的连边在树上必须没有，权值为两点在树上的距离。\n求这个图的最小生成树。\n思路由 Kruskal 可知，我们可以先连权值为  的边，然后再连 。\n可以将深度相同的连，然后再将深度差  的点连起来。\n最后将两个连通块连一条长度为  的边。\n注意到菊花图是无解的。\n所以答案就是 。\n需要特判 。\nT2赛时读错题了，本来想着可以二分，但是写着发现不对，正解不好想，想到了 DP 转移，又考虑了如何优化，代码细节很多，耗时两个半小时。\n估分：\n实际：\n题意一个序列分成几个子序列，求所有子序列的  的  的最大值。\n思路考虑答案的最大值，计算得出只有 ，考虑状压 DP。\n令  表示前  个数，子序列的  状态为  的方案能否到达。\n对于每一个状态，可以往后找  个区间，然后暴力更新。\n这样的做法时间复杂度是不可以接受的。\n我们发现，当一些左端点相同的区间的  相同的时候，只需要取右端点最靠左的区间就行了，因为去前面的不会让  更劣。\n因为  很小  可以  去求，维护一下上面这个东西就做完了。\n25.10.21做题记录格雷码题意顾名思义，输出一个数的格雷码。\n思路去百度上研究了定义，然后找了找规律，然后做完了，十分钟。\n通过打表可知，答案是  的二进制反过来做完了。\n廊桥分配题意一个机场，分给国内和国际廊桥，一个飞机在廊桥的停靠有时间段，问你在廊桥停靠的飞机的数量最大值。\n思路思考未果，看了眼题解，没想到是 T1 ，代码也不好写，一个小时。\n分配廊桥的过程可以用优先队列来模拟，可以维护出哪些廊桥可用。枚举分给某个区的廊桥数，在预处理的时候做前缀和优化就做完了。\n25.10.22做题记录假期计划题意一个无向图，确定一条路线 ，要求每两点之间最短路的点数不超过 ，问你这四个点的权值和的最大值。\n思路听了 Gyf 讲，马上就会了，写代码用了不到一个小时。\n给 Gyf 大神磕头了 /bx\n边权都是 ，可以 BFS  预处理最短路，然后  暴力枚举。显然会 TLE。\n我们发现，当  确定， 是可以近似  算出的。在 BFS 中预处理出这个点可以到达的点，并且这个点能到达 ，显然点权取最大最好。但考虑到  会有重复，所以维护前  大。这就是  的做法。\n将路径反过来，会发现原来的  变成了 。也就是说， 的维护可以和  相同，所以说可以做到 。\n括号树题意一棵树，树上有左右括号，求出从  到某个点的合法括号子串的数量。\n思路搬了一道相似题的代码的思路，但是被细节问题卡了半个多小时。\n我的精神状态：)( 是合法括号串。\n一眼看和那道消消乐很类似，所以可以照搬消消乐的 DP 思路。\n但是有两个细节：\n\n每次搜完要进行回溯\n只有 ) 可以进行 DP 转移\n\n可以  统计每次的答案，但是因为我太唐写了个树状数组。\n我偷偷加一个  应该没人看见吧。\n括号序列题意一个字符串，有些地方可以选填左/右括号或者空，对空的数量有限制，问你整个字符串合法的方案数。\n思路听了 Gyf 讲，一个小时左右。\n因为括号序列一定是一些括号和空拼起来的，所以可以根据左右两边的字符去设置状态，因为左右两边的字符影响到了它的拼接。\n然后确定了 () 之后可以直接进行 DP。\n回文题意一个序列，每次移除开头或者末尾放入另一个，问你最后能否达成回文，如果可以，输出字典序最小的方案（优先移除开头的方案）。\n思路和 aa，Gyf 共享了思路和代码，但是出了点细节小问题，而且后面去听唐彬峪的课了，用时一个半小时。\n考虑到字典序最小直接贪心去解决，开两个双端队列来存储下来当前的状态，如果能够到达的状态就直接弹出，然后开两个 vector 来存储答案，注意到最后要按照题目顺序输出。\n25.10.23比赛总结T1赛时想了个思路，写了写过了样例，因为没有大样例直接交了。然后被同学的 Hack 给干掉了，又整理了思路重新写了写，码量不是很大，耗时一个小时左右。\n估分：\n实际：\n题意一个数初始为 ，每次可以加  中的整数（），问你是否能经过  次操作后恰好到达 。\n思路T1 放大分讨出题人我爱你。\n\n 是  的一个倍数，因为这样操作数最小，所以说判断  是否合法就行了。\n 不是  的倍数且 ，这样最小操作数是  次操作，直接判断。\n否则全放  一定不满足条件，所以说只能选  和 ，就变成了经典的鸡兔同笼问题，判断是否合法即可。\n\nT2赛时思考将近一个小时无果，果断去打暴力，总耗时一个半小时。\n估分：\n实际：\n题意有一些机器人，若脚下的点不被染色，给脚下的点染色，控制这些机器人同时向左或向右，求最后每个机器人染色的点数。\n思路手玩几组样例，会发现两个机器人之间的段只能是左边和右边的机器人染色，其实这个通过相对静止也能看出来。\n可以维护前几次操作，想左偏移的最大值和向右偏移的最大值。对于每个间隔，可以二分出最后一个互不侵犯的位置，最后根据下一次操作的正负性来判断空着的一段给谁。\n时间复杂度 ，能过。\nT3赛时没打。\n估分：\n实际：\n赛后去补，因为写法问题常数慢了好几倍，所以直接交的 std。\n题意有一个图，左上全黑，剩下三块按这种方法涂。特别地，只有一个就是白色。\n问你两个这样的图平移重叠之后，问你最后都是白色的数量。\n思路发现当最高位分别为  时，它才会被涂为黑色。然后对于 DP 的每一位，枚举当前的位数和它的进位，平凡转移。\n25.10.24做题记录「DTOI-5」进行一个排的重 (Minimum Version)题意 和  是排列，让你重排。求这个东西的最小值：\n思路式子一眼不会看，反复思考无果，看的题解，发现很简单，半个小时左右。\n首先是  ，可以将两个放在前面，答案是 ，剩下的随便放，方案是 。\n否则必须将一个  放在前面因为后面的  会对它产生贡献，答案是 ，方案是 。\nColor Rows and Columns题意有一些矩阵，涂完一行或一列获得  分，问你获得至少一定分数的最小的代价。\n思路和 Gyf 共享了思路，在 Gyf 的指导下完成了代码，二十分钟。\n考虑 DP。设  表示考虑到第  个，当前分数为  的最小代价。对于每个矩阵，预处理用一定代价获得的最大收益，可以平凡的转移，时间复杂度可行。\nLeague of Leesins题意有一个排列，以  为滑动窗口大小，形成  个窗口。将每个窗口打乱，给你打乱的这几个三元组，让你还原其中一个排列。\n思路很简单，口胡了一个思路和别人对了一下发现是对的。发现是很对的，代码不好写，半个小时左右。\n首先一个边界元素的出现次数显然是 。\n然后确定一个，找到和它在一个三元组里，出现次数为  的数就是第二个数。\n然后根据两个可以在三元组中推断出下一个。\n","categories":["2025"],"tags":["个人记录"]}]